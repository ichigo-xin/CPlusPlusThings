# const

## 定义常量
必须给定初始值

## const和指针
- 指向常量的指针  
  const int *p p所指向的值不能通过p来修改
- 常指针  
  int * const p p所包含的地址是不变的，即指针不变
- 指向常量的常指针
  
## const和函数
主要是const修饰指针参数和引用  
void fun1(const A *a)  
void fun2(const A &a)  
目的：为了不会在函数内部改变传入参数的值，同时可以节省空间。  
  
对于非内部数据类型作为输入参数，应当使用“const引用”方式，提高效率，而对于内部数据类型，则直接使用值传递就行。

---
# static

## static 修饰静态变量
- 函数中的静态变量  
  只分配一次，共用
- 类中的静态变量  
  分配一次，公用

## 类对象是静态的  
静态对象的作用域是整个程序的生命周期

## 类中的静态函数
也不依赖于特定的类实例

---
# inline

## 内联用空间换时间，复制代码节省调用时间
## 虚函数可以内联，不过必须是不表现多态的时候，因为内联是编译期确定，而多态是运行期

---
# 纯虚函数和抽象类
- 纯虚函数是=0的虚函数，没有函数体
- 含有纯虚函数的类是抽象类，抽象类不能实例化
- 指针
  
---
# 虚函数的 vptr 和 vtable
为了实现虚函数，C++ 使用虚拟表进行后期绑定，该虚拟表是用于解决在动态/后期绑定方式的函数调用查找表

---
# virtual
## 虚函数和默认参数
虚函数是动态绑定的，而默认参数是静态绑定的，因此默认参数应该看指针本身，而不是看对象类型

## 其他
- 静态函数不能声明为虚函数
- 构造函数不能声明为虚函数
  
---
# volatile
volatile 实际上是不稳定的意思，告诉编译器不要进行优化，如多线程中就是表示每次都从内存中取值，而不是从优化后的寄存器中取值，即实现了可见性了。

---
# assert
- 断言是宏，而非函数
- 用于检查逻辑上的不可能，通常在运行时被禁用  #define NDEBUG 相当于直接忽略了assert语句

---
# 位域
- 位域在内存中的布局和机器有关
- 位域的类型必须是整型或者枚举类型
- 位域通常使用结构体声明，为每个位域成员设置名称，并且决定其宽度

---
# extern
c++ 中调用c的函数

---
# explicit
防止隐式转换

---
# friend
- 友元关系没有继承性  
- 友元关系没有传递性
- 友元破坏了封装性
  
---
# using




